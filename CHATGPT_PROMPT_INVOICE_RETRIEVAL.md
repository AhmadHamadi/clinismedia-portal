# QuickBooks Invoice Retrieval Logic - Explanation for ChatGPT

## Customer Mapping System

Before retrieving invoices, we map CliniMedia portal customers (MongoDB User documents with role='customer') to QuickBooks customers. We use a `QuickBooksCustomerMapping` collection with three fields: `portalCustomerId` (MongoDB ObjectId reference to User), `quickbooksCustomerId` (String - QuickBooks Customer ID), and `quickbooksCustomerDisplayName` (String). When an admin maps a customer, the frontend sends a POST to `/api/quickbooks/map-customer` with both IDs. The backend uses `findOneAndUpdate` with `upsert: true` to create or update the mapping. Each portal customer can only be mapped to one QuickBooks customer (enforced by a unique index on `portalCustomerId`). The frontend loads all mappings by calling `GET /api/quickbooks/mapped-customers`, which populates the `portalCustomerId` field to get customer details.

## QuickBooks API Authentication

We use OAuth 2.0 for authentication. The admin connects QuickBooks once, and we store the access token, refresh token, realm ID (company ID), and token expiry in the User model. Access tokens expire after about 1 hour. We have a `getValidAccessToken()` helper that checks if the token is expired (with a 5-minute buffer) and automatically refreshes it using the refresh token if needed. Since only one admin connects QuickBooks (single-tenant), we use `getQuickBooksConnectionOwner()` to find the user with `quickbooksConnected: true`. This user's tokens and realm ID are used for all QuickBooks API calls. The realm ID is crucial because it identifies which QuickBooks company to query.

## Invoice Retrieval Process

To fetch invoices for a mapped customer, we call the QuickBooks Query API: `GET /v3/company/{realmId}/query`. We construct a SQL-like query: `SELECT * FROM Invoice WHERE CustomerRef = '{quickbooksCustomerId}' ORDERBY TxnDate DESC MAXRESULTS 100`. This retrieves all invoices for a specific QuickBooks customer, ordered by transaction date (newest first), with a maximum of 100 results. The `runQuery()` method in `QuickBooksService` handles this API call by constructing the full URL with the encoded query string and making a GET request with the Bearer token in the Authorization header.

The QuickBooks API returns a JSON response with structure: `{ QueryResponse: { Invoice: [...], totalCount: X } }`. If there's one invoice, `QueryResponse.Invoice` is a single object. If there are multiple, it's an array. If there are no invoices, it might be undefined or empty. We handle this by checking if the result is an array, and if not, converting a single object to an array: `Array.isArray(invoices) ? invoices : [invoices]`.

## Invoice Normalization

After retrieving raw invoices, we normalize them using `normalizeInvoice()`. This method extracts key fields: `Id` becomes `id`, `DocNumber` becomes `docNumber`, `TxnDate` becomes `txnDate`, `DueDate` becomes `dueDate`, `TotalAmt` becomes `totalAmount` (converted to Number), and `Balance` becomes `balance` (converted to Number). The normalization calculates status based on balance and total amount: if `balance === 0`, status is `'paid'`. If `balance === totalAmount`, status is `'unpaid'`. If `balance > 0 && balance < totalAmount`, status is `'partial'`. Otherwise, status is `'unknown'`. The normalized invoice includes: `id`, `docNumber`, `txnDate`, `dueDate`, `totalAmount`, `balance`, `status`, `customerRef`, `currencyRef`, `billEmail`, `lineItems`, and `raw` (the complete original invoice for debugging).

## Backend Route for Invoice Retrieval

The route `GET /api/quickbooks/customer/:portalCustomerId/invoices` handles invoice retrieval. First, it validates user permission (customers can only see their own invoices). Then, it looks up the mapping for the given `portalCustomerId` in `QuickBooksCustomerMapping`. If no mapping exists, it returns 404. Next, it gets the QuickBooks connection owner and validates that QuickBooks is connected (checks for access token and realm ID). It calls `getValidAccessToken()` to ensure the token is fresh. Finally, it calls `QuickBooksService.getNormalizedInvoicesForCustomer()`, which internally calls `getInvoicesForCustomer()` to fetch raw invoices, then maps each invoice through `normalizeInvoice()` to return an array of normalized invoices. The route returns `{ invoices: [...] }`. If there's an error, it catches it, logs it, and returns a 500 error with a generic message.

## Frontend Invoice Loading

When the admin clicks "Load Invoices", the `loadInvoices()` function is triggered. It validates that QuickBooks is connected and that there are mapped customers. Then, it iterates through all mappings and creates a promise for each mapping that fetches invoices for that portal customer. For each mapping, it extracts the `portalCustomerId` (handling both cases where it's an object with `_id` or a plain string). It makes an axios GET request to `/api/quickbooks/customer/${portalCustomerId}/invoices` with the admin token in the Authorization header. If the request fails, it catches the error and returns an empty array instead of throwing, to prevent one failed request from breaking the entire process.

After receiving invoices from the backend, the frontend processes each invoice. It validates that each invoice has an `id` field (required for React keys). Then, it maps the normalized status (`'paid'`, `'unpaid'`, `'partial'`, `'unknown'`) to the frontend status (`'Paid'`, `'NotPaid'`, `'Overdue'`). If the status is `'paid'`, the frontend status is `'Paid'`. Otherwise, it checks if the invoice is overdue by comparing the `dueDate` to today's date (if the due date is in the past and the status is not paid, it's overdue). If overdue, the frontend status is `'Overdue'`. If not overdue and status is `'unpaid'` or `'partial'`, the frontend status is `'NotPaid'`. The frontend also extracts the currency from the `currencyRef` object (`currencyRef.value`) or falls back to `'USD'`. It gets the customer name from the mapping (`quickbooksCustomerDisplayName`) or from the invoice's `customerRef.name`, or defaults to `'Unknown'`.

## Aggregating and Filtering Invoices

After processing invoices for all mapped customers, the frontend uses `Promise.allSettled()` to wait for all promises to complete (whether they succeed or fail). It then flattens all invoice arrays into a single array and filters out any null or undefined values, and any invoices without an `id` field. The frontend applies a filter based on the selected status filter (`'all'`, `'Paid'`, `'NotPaid'`, `'Overdue'`). If the filter is not `'all'`, it filters the invoices array to only include invoices matching the selected status. Finally, it sets the filtered invoices in React state using `setInvoices()`. Even if there are no invoices, it sets an empty array to prevent the component from crashing. If there are no invoices, it sets an error message. If there are invoices but none match the filter, it sets a different error message suggesting the user try "All Status".

## Rendering Invoices

The frontend renders invoices in a table. It checks if `invoices` is an array and if it has length. If loading, it shows a spinner. If empty or not an array, it shows a message. Otherwise, it renders a table with columns: Invoice #, Customer, Date, Due Date, Total, Balance, Status, and Actions. Each invoice row displays the `docNumber`, `customerName`, formatted dates (using `formatDate()` which converts date strings to locale date format), formatted currency (using `formatCurrency()` which uses Intl.NumberFormat), and a status badge with different colors (green for Paid, red for Overdue, yellow for Not Paid). The Actions column includes a link to open the invoice in QuickBooks using the URL: `https://qbo.intuit.com/app/invoice?txnId=${invoiceId}`.

## Error Handling

The backend has multiple layers of error handling. If the mapping doesn't exist, it returns 404. If QuickBooks is not connected, it returns 400. If the token is invalid or expired, `getValidAccessToken()` will try to refresh it, and if that fails, it throws an error that gets caught and returns 500. If the QuickBooks API returns an error (e.g., invalid customer ID, API rate limit, network error), the error is caught in the route handler, logged with `console.error()`, and a generic 500 error is returned. The actual error details are logged but not sent to the client for security reasons.

The frontend has extensive error handling to prevent the page from going blank. Each promise in the invoice loading process has a try-catch block. If a request fails, it returns an empty array instead of throwing. If an invoice is invalid (missing `id`), it's filtered out and a warning is logged. The `Promise.allSettled()` ensures that even if some requests fail, the others can still succeed. The frontend always sets the invoices state (even if empty) to prevent React from crashing. It also validates that `invoices` is an array before trying to map over it in the render function.

## Current Issues

**Issue 1: Mapping Doesn't Update UI** - When mapping a customer, the frontend sends `clinimediaCustomerId` but the backend expects `portalCustomerId`. We've added support for both field names, but the frontend needs to reload mappings after a successful mapping. The `handleMapCustomer()` function calls `loadMappings()` after mapping, but if there's an error or the response format is unexpected, the UI might not update.

**Issue 2: Blank Screen When Loading Invoices** - When loading invoices, the page sometimes goes blank. This could be caused by: React component crashing due to invalid data, error in invoice processing causing the component to unmount, or state update causing infinite re-render loop. We've added extensive error handling, but if an invoice has an unexpected structure or a required field is missing in an unexpected way, it could still cause issues.

## Debugging Steps

To debug invoice retrieval issues, check: browser console for `[Frontend]` logs (shows each step of the process), backend terminal for `[QuickBooks]` logs (shows API calls and responses), network tab in browser dev tools (shows actual HTTP requests and responses), and QuickBooks API response structure (the `raw` field in normalized invoices contains the original response). Common problems include: QuickBooks API returning empty array (customer has no invoices, query syntax incorrect, customer ID wrong), token expired and refresh failing (need to reconnect QuickBooks), mapping not found (portal customer ID doesn't match, mapping was deleted), invalid invoice data (missing required fields, unexpected data types), and network errors (QuickBooks API down, timeout, CORS issues).

## QuickBooks API Query Syntax

The QuickBooks Query API uses a SQL-like syntax. Our query: `SELECT * FROM Invoice WHERE CustomerRef = '{quickbooksCustomerId}' ORDERBY TxnDate DESC MAXRESULTS 100` selects all fields from the Invoice entity, filters by CustomerRef (the customer ID), orders by transaction date descending (newest first), and limits to 100 results. The `CustomerRef` field in QuickBooks is a reference object that contains `value` (the customer ID) and `name` (the customer name). In the WHERE clause, we use the customer ID directly as a string. The query is URL-encoded before being sent to the API. The response structure is: `{ QueryResponse: { Invoice: [...], maxResults: 100, startPosition: 1, totalCount: X } }`. The `Invoice` field can be a single object or an array, and `totalCount` indicates how many total invoices match the query (may be more than the returned results if there are more than 100).

## Token Refresh Logic

The `getValidAccessToken()` helper function checks if the current access token is expired by comparing the `quickbooksTokenExpiry` timestamp to the current time, with a 5-minute buffer. If the token is expired (or will expire within 5 minutes), it calls `QuickBooksService.refreshAccessToken()` with the refresh token. The refresh token request is made to `https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer` with `grant_type=refresh_token` and the refresh token. QuickBooks returns a new access token and optionally a new refresh token. We update the user's token fields in the database and return the new access token. If the refresh fails (e.g., refresh token is invalid or expired), the error is caught and logged, and the function throws an error. This means the user needs to reconnect QuickBooks through the OAuth flow to get new tokens.

